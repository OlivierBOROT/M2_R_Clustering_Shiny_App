% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/04_PDDP_clusterer.R
\name{DivisiveClusterer}
\alias{DivisiveClusterer}
\title{Divisive Clustering for Variables (VARCLUS-style) - HYBRID VERSION}
\description{
R6 class that implements divisive (top-down) hierarchical clustering of variables
with enhanced robustness, multiple stopping criteria, and quality metrics.
This algorithm starts with all variables in one cluster and iteratively splits the most
heterogeneous cluster based on PCA eigenvalues and Varimax rotation.

\strong{Hybrid Architecture:} Automatically detects data type and uses:
\itemize{
\item \strong{Fast Path (numeric only):} eigen(cor(X)) - O(p^2) complexity, very fast
\item \strong{General Path (mixed data):} PCAmix via PCAmixdata package - handles factors
}

Both paths yield mathematically equivalent results for numeric data.
}
\details{
Algorithm workflow:
\enumerate{
\item Initialize: All variables start in one cluster
\item \strong{Detect data type:} Pure numeric -> fast correlation path; Mixed -> PCAmix path
\item Iterate until reaching k clusters or stopping criterion met:
\itemize{
\item Select cluster with highest 2nd eigenvalue (most heterogeneous)
\item Check stopping criteria (Kaiser, eigenvalue ratio)
\item Perform PCA on that cluster (method depends on data type)
\item Apply Varimax rotation to first 2 components
\item Split variables based on squared correlations with rotated components
\item Validate split quality (prevent empty clusters)
}
\item Each cluster center is its 1st principal component
}

Advantages:
\itemize{
\item Deterministic (no random initialization)
\item Interpretable hierarchy of splits (100\% stable)
\item \strong{Hybrid speed:} Fast for numeric, flexible for mixed data
\item Multiple stopping criteria (Kaiser, eigenvalue ratio)
\item Split quality metrics for diagnostics
\item Supports categorical variables via PCAmix (MCA + PCA fusion)
}
}
\examples{
\dontrun{
data <- data.frame(matrix(rnorm(1000), ncol = 10))
colnames(data) <- paste0("Var", 1:10)

# Basic usage
clusterer <- DivisiveClusterer$new(data, n_clusters = 3)
clusterer$fit()
clusterer$print()

# With custom parameters
clusterer <- DivisiveClusterer$new(
  data,
  n_clusters = 4,
  min_cluster_size = 2,
  rotation_method = "varimax",
  split_criterion = "eigenvalue2"
)
clusterer$fit()

# With Kaiser stopping rule (auto-stop when lambda2 < 1)
clusterer <- DivisiveClusterer$new(
  data,
  n_clusters = 10, # Maximum clusters
  stop_at_kaiser = TRUE
)
clusterer$fit()

# With eigenvalue ratio stopping rule (more flexible)
clusterer <- DivisiveClusterer$new(
  data,
  n_clusters = 10,
  min_eigenvalue_ratio = 0.15 # Stop if lambda2/lambda1 < 0.15
)
clusterer$fit()

# Get interpretable hierarchy
history <- clusterer$get_split_history()
print(history)

# Export results
assignments <- clusterer$get_cluster_assignments()
quality <- clusterer$get_split_quality_summary()

# Visualize (shows lambda2/lambda1 ratio)
plot_clustering_2d(clusterer)
clusterer$plot_split_dendrogram()

# Use with Elbow method (get_inertia returns 1 - homogeneity)
inertia <- clusterer$get_inertia()
}

}
\section{Super class}{
\code{M2RClust::BaseClusterer} -> \code{DivisiveClusterer}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{split_history}}{History of cluster splits (for interpretability)}

\item{\code{cluster_centers}}{List of cluster centers (1st PC of each cluster)}

\item{\code{cluster_eigenvalues}}{Eigenvalues for each final cluster}

\item{\code{cluster_pca}}{List of PCA objects for each cluster (for compatibility)}

\item{\code{cluster_homogeneity}}{Homogeneity scores for each cluster}

\item{\code{min_cluster_size}}{Minimum variables per cluster for splitting}

\item{\code{rotation_method}}{Rotation method for PCA ("varimax", "promax", "none")}

\item{\code{split_criterion}}{Criterion for selecting cluster to split}

\item{\code{stop_at_kaiser}}{Whether to stop splitting when eigenvalue2 < 1.0 (Kaiser criterion)}

\item{\code{min_eigenvalue_ratio}}{Minimum eigenvalue ratio (lambda2/lambda1) for splitting}

\item{\code{promax_m}}{Power parameter for Promax rotation (default 4)}

\item{\code{cluster_eigenvalue2_cache}}{Cache of 2nd eigenvalues for each cluster (performance optimization)}

\item{\code{use_fast_path}}{Logical flag indicating if fast numeric path is used (TRUE) or mixed PCAmix path (FALSE)}

\item{\code{global_cor}}{Pre-computed correlation matrix (only for fast numeric path)}

\item{\code{data_mode}}{Character indicating data type: "numeric" or "mixed"}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-DivisiveClusterer-new}{\code{DivisiveClusterer$new()}}
\item \href{#method-DivisiveClusterer-fit}{\code{DivisiveClusterer$fit()}}
\item \href{#method-DivisiveClusterer-predict}{\code{DivisiveClusterer$predict()}}
\item \href{#method-DivisiveClusterer-print}{\code{DivisiveClusterer$print()}}
\item \href{#method-DivisiveClusterer-summary}{\code{DivisiveClusterer$summary()}}
\item \href{#method-DivisiveClusterer-get_centers}{\code{DivisiveClusterer$get_centers()}}
\item \href{#method-DivisiveClusterer-get_split_history}{\code{DivisiveClusterer$get_split_history()}}
\item \href{#method-DivisiveClusterer-get_cluster_homogeneity}{\code{DivisiveClusterer$get_cluster_homogeneity()}}
\item \href{#method-DivisiveClusterer-get_homogeneity}{\code{DivisiveClusterer$get_homogeneity()}}
\item \href{#method-DivisiveClusterer-get_unexplained_variance}{\code{DivisiveClusterer$get_unexplained_variance()}}
\item \href{#method-DivisiveClusterer-get_inertia}{\code{DivisiveClusterer$get_inertia()}}
\item \href{#method-DivisiveClusterer-get_cluster_pca}{\code{DivisiveClusterer$get_cluster_pca()}}
\item \href{#method-DivisiveClusterer-get_cluster_assignments}{\code{DivisiveClusterer$get_cluster_assignments()}}
\item \href{#method-DivisiveClusterer-get_split_quality_summary}{\code{DivisiveClusterer$get_split_quality_summary()}}
\item \href{#method-DivisiveClusterer-plot_split_dendrogram}{\code{DivisiveClusterer$plot_split_dendrogram()}}
\item \href{#method-DivisiveClusterer-get_split_details}{\code{DivisiveClusterer$get_split_details()}}
\item \href{#method-DivisiveClusterer-get_hierarchy_tree}{\code{DivisiveClusterer$get_hierarchy_tree()}}
\item \href{#method-DivisiveClusterer-get_plot_data}{\code{DivisiveClusterer$get_plot_data()}}
\item \href{#method-DivisiveClusterer-prepare_plot_predict}{\code{DivisiveClusterer$prepare_plot_predict()}}
\item \href{#method-DivisiveClusterer-get_plot_data_predict}{\code{DivisiveClusterer$get_plot_data_predict()}}
\item \href{#method-DivisiveClusterer-clone}{\code{DivisiveClusterer$clone()}}
}
}
\if{html}{\out{
<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="M2RClust" data-topic="BaseClusterer" data-id="get_cluster_members"><a href='../../M2RClust/html/BaseClusterer.html#method-BaseClusterer-get_cluster_members'><code>M2RClust::BaseClusterer$get_cluster_members()</code></a></span></li>
<li><span class="pkg-link" data-pkg="M2RClust" data-topic="BaseClusterer" data-id="get_cluster_sizes"><a href='../../M2RClust/html/BaseClusterer.html#method-BaseClusterer-get_cluster_sizes'><code>M2RClust::BaseClusterer$get_cluster_sizes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="M2RClust" data-topic="BaseClusterer" data-id="get_n_observations"><a href='../../M2RClust/html/BaseClusterer.html#method-BaseClusterer-get_n_observations'><code>M2RClust::BaseClusterer$get_n_observations()</code></a></span></li>
<li><span class="pkg-link" data-pkg="M2RClust" data-topic="BaseClusterer" data-id="get_n_variables"><a href='../../M2RClust/html/BaseClusterer.html#method-BaseClusterer-get_n_variables'><code>M2RClust::BaseClusterer$get_n_variables()</code></a></span></li>
<li><span class="pkg-link" data-pkg="M2RClust" data-topic="BaseClusterer" data-id="get_results"><a href='../../M2RClust/html/BaseClusterer.html#method-BaseClusterer-get_results'><code>M2RClust::BaseClusterer$get_results()</code></a></span></li>
<li><span class="pkg-link" data-pkg="M2RClust" data-topic="BaseClusterer" data-id="reset"><a href='../../M2RClust/html/BaseClusterer.html#method-BaseClusterer-reset'><code>M2RClust::BaseClusterer$reset()</code></a></span></li>
<li><span class="pkg-link" data-pkg="M2RClust" data-topic="BaseClusterer" data-id="save_results"><a href='../../M2RClust/html/BaseClusterer.html#method-BaseClusterer-save_results'><code>M2RClust::BaseClusterer$save_results()</code></a></span></li>
</ul>
</details>
}}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DivisiveClusterer-new"></a>}}
\if{latex}{\out{\hypertarget{method-DivisiveClusterer-new}{}}}
\subsection{Method \code{new()}}{
Create a new DivisiveClusterer object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DivisiveClusterer$new(
  data,
  n_clusters,
  standardize = TRUE,
  min_cluster_size = 3,
  rotation_method = "varimax",
  split_criterion = "eigenvalue2",
  stop_at_kaiser = FALSE,
  min_eigenvalue_ratio = 0.1,
  promax_m = 4
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{The dataset to be clustered (variables in columns).}

\item{\code{n_clusters}}{The number of clusters to form.}

\item{\code{standardize}}{Whether to standardize the data (default TRUE).}

\item{\code{min_cluster_size}}{Minimum number of variables required to split a cluster (default 3).}

\item{\code{rotation_method}}{Rotation method: "varimax" (default), "promax", or "none".}

\item{\code{split_criterion}}{Criterion for selecting cluster to split: "eigenvalue2" (default) or "homogeneity".}

\item{\code{stop_at_kaiser}}{Logical. If TRUE, stop splitting when max 2nd eigenvalue < 1.0 (default FALSE).}

\item{\code{min_eigenvalue_ratio}}{Numeric. Minimum lambda2/lambda1 ratio required to continue splitting (default 0.1).}

\item{\code{promax_m}}{Numeric. Power parameter for Promax rotation (default 4). Only used when rotation_method = "promax".}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new \code{DivisiveClusterer} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DivisiveClusterer-fit"></a>}}
\if{latex}{\out{\hypertarget{method-DivisiveClusterer-fit}{}}}
\subsection{Method \code{fit()}}{
Fit the divisive clustering algorithm to the data.
Automatically detects data type and uses optimal computation path.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DivisiveClusterer$fit()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The fitted divisive clustering model (self, invisibly).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DivisiveClusterer-predict"></a>}}
\if{latex}{\out{\hypertarget{method-DivisiveClusterer-predict}{}}}
\subsection{Method \code{predict()}}{
Predict the cluster labels for new variables based on squared correlations with cluster centers.
Uses hybrid logic: vectorized cor() for numeric data, eta-squared for categorical variables.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DivisiveClusterer$predict(new_data)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{new_data}}{New data points (observations in rows, variables in columns).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A vector of predicted cluster labels.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DivisiveClusterer-print"></a>}}
\if{latex}{\out{\hypertarget{method-DivisiveClusterer-print}{}}}
\subsection{Method \code{print()}}{
Print method for DivisiveClusterer
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DivisiveClusterer$print()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DivisiveClusterer-summary"></a>}}
\if{latex}{\out{\hypertarget{method-DivisiveClusterer-summary}{}}}
\subsection{Method \code{summary()}}{
Summary method for DivisiveClusterer
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DivisiveClusterer$summary()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A summary of the divisive clustering model.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DivisiveClusterer-get_centers"></a>}}
\if{latex}{\out{\hypertarget{method-DivisiveClusterer-get_centers}{}}}
\subsection{Method \code{get_centers()}}{
Get cluster centers for visualization or further analysis
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DivisiveClusterer$get_centers()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
List of cluster centers (1st PC scores for each cluster)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DivisiveClusterer-get_split_history"></a>}}
\if{latex}{\out{\hypertarget{method-DivisiveClusterer-get_split_history}{}}}
\subsection{Method \code{get_split_history()}}{
Get the split history for interpretability
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DivisiveClusterer$get_split_history()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
List containing split history
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DivisiveClusterer-get_cluster_homogeneity"></a>}}
\if{latex}{\out{\hypertarget{method-DivisiveClusterer-get_cluster_homogeneity}{}}}
\subsection{Method \code{get_cluster_homogeneity()}}{
Get cluster homogeneity scores (compatibility with KMeansClusterer)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DivisiveClusterer$get_cluster_homogeneity()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Numeric vector of homogeneity scores
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DivisiveClusterer-get_homogeneity"></a>}}
\if{latex}{\out{\hypertarget{method-DivisiveClusterer-get_homogeneity}{}}}
\subsection{Method \code{get_homogeneity()}}{
Get global homogeneity score (compatibility with KMeansClusterer)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DivisiveClusterer$get_homogeneity()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Numeric value (weighted average homogeneity)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DivisiveClusterer-get_unexplained_variance"></a>}}
\if{latex}{\out{\hypertarget{method-DivisiveClusterer-get_unexplained_variance}{}}}
\subsection{Method \code{get_unexplained_variance()}}{
Get unexplained variance metric for Elbow Method (Lower is better).
Returns (1 - Global Homogeneity). This is the proportion of variance NOT
explained by the first principal component of each cluster.
Note: This differs from K-Means "inertia" (sum of squared distances).
For variable clustering, we use correlation-based metrics instead.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DivisiveClusterer$get_unexplained_variance()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Numeric value in \code{[0, 1]} representing unexplained variance
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DivisiveClusterer-get_inertia"></a>}}
\if{latex}{\out{\hypertarget{method-DivisiveClusterer-get_inertia}{}}}
\subsection{Method \code{get_inertia()}}{
Alias for get_unexplained_variance() for compatibility with validation tools.
Note: Unlike K-Means inertia (SSE), this returns (1 - homogeneity).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DivisiveClusterer$get_inertia()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Numeric value representing unexplained variance
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DivisiveClusterer-get_cluster_pca"></a>}}
\if{latex}{\out{\hypertarget{method-DivisiveClusterer-get_cluster_pca}{}}}
\subsection{Method \code{get_cluster_pca()}}{
Get PCA objects for each cluster (compatibility with KMeansClusterer)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DivisiveClusterer$get_cluster_pca()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
List of PCA-like objects
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DivisiveClusterer-get_cluster_assignments"></a>}}
\if{latex}{\out{\hypertarget{method-DivisiveClusterer-get_cluster_assignments}{}}}
\subsection{Method \code{get_cluster_assignments()}}{
Export cluster assignments as a tidy data frame
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DivisiveClusterer$get_cluster_assignments()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Data frame with variable, cluster, and homogeneity columns
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DivisiveClusterer-get_split_quality_summary"></a>}}
\if{latex}{\out{\hypertarget{method-DivisiveClusterer-get_split_quality_summary}{}}}
\subsection{Method \code{get_split_quality_summary()}}{
Get split quality summary as a data frame
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DivisiveClusterer$get_split_quality_summary()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Data frame with detailed split metrics
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DivisiveClusterer-plot_split_dendrogram"></a>}}
\if{latex}{\out{\hypertarget{method-DivisiveClusterer-plot_split_dendrogram}{}}}
\subsection{Method \code{plot_split_dendrogram()}}{
Plot the history of splits as a tree diagram (top-down dendrogram)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DivisiveClusterer$plot_split_dendrogram(
  main = "Divisive Clustering Tree",
  show_eigenvalues = TRUE,
  show_vars = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{main}}{Character string for plot title}

\item{\code{show_eigenvalues}}{Whether to show eigenvalues on branches}

\item{\code{show_vars}}{Whether to show variable counts in nodes}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DivisiveClusterer-get_split_details"></a>}}
\if{latex}{\out{\hypertarget{method-DivisiveClusterer-get_split_details}{}}}
\subsection{Method \code{get_split_details()}}{
Get detailed split information as data frame
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DivisiveClusterer$get_split_details()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Data frame with split details
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DivisiveClusterer-get_hierarchy_tree"></a>}}
\if{latex}{\out{\hypertarget{method-DivisiveClusterer-get_hierarchy_tree}{}}}
\subsection{Method \code{get_hierarchy_tree()}}{
Get hierarchy tree structure for external visualization
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DivisiveClusterer$get_hierarchy_tree()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
List representing the split tree
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DivisiveClusterer-get_plot_data"></a>}}
\if{latex}{\out{\hypertarget{method-DivisiveClusterer-get_plot_data}{}}}
\subsection{Method \code{get_plot_data()}}{
Prepare data for the 2D correlation circle plot (compatibility with plot_clustering_2d).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DivisiveClusterer$get_plot_data()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list with coords, colors, pca, and centers for visualization.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DivisiveClusterer-prepare_plot_predict"></a>}}
\if{latex}{\out{\hypertarget{method-DivisiveClusterer-prepare_plot_predict}{}}}
\subsection{Method \code{prepare_plot_predict()}}{
Prepare data for plotting with illustrative/supplementary variables.
Projects new variables onto the global PCA space for visualization.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DivisiveClusterer$prepare_plot_predict(new_data, pred_result = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{new_data}}{New data frame with same observations as training data.}

\item{\code{pred_result}}{Optional prediction result (from predict()). If NULL, will call predict().}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Self (invisibly).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DivisiveClusterer-get_plot_data_predict"></a>}}
\if{latex}{\out{\hypertarget{method-DivisiveClusterer-get_plot_data_predict}{}}}
\subsection{Method \code{get_plot_data_predict()}}{
Get data for plotting with supplementary variables (compatibility with plot_clustering_with_supp).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DivisiveClusterer$get_plot_data_predict()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list with coords (including illustrative), colors, pca, and centers for visualization.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DivisiveClusterer-clone"></a>}}
\if{latex}{\out{\hypertarget{method-DivisiveClusterer-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DivisiveClusterer$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
